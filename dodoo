#!/usr/bin/env python
import argparse
from pygit2 import Repository, discover_repository
import os
import sys
from functools import wraps


def pprint(msg, log_decoration=' :: '):
    """Mostly borrowed from Marabunta :3"""
    supports_colors = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()
    if supports_colors:
        template = u'\033[1m{}{}\033[0m'
    else:
        template = u'{}{}'
    print(template.format(log_decoration, msg))


def parse_arguments():
    """Parses args from command line, decides what and how to run next.

    The majority of dodoo structure is defined here.
    """
    parser = argparse.ArgumentParser(
        description='An CLI porcelain to interact with '
        'C2C dockerized Odoo architecture.')

    # Global arguments
    parser.add_argument(
        '-db', '--dbname', help='database name to operate onto')
    parser.add_argument(
        '-n', '--dryrun', action='store_true',
        help='only print commands instead of execution')

    dbnames = parser.add_mutually_exclusive_group()
    dbnames.add_argument(
        '--core', action='store_true', help='run on: odoodb')
    dbnames.add_argument(
        '--test', action='store_true', help='..: testdb, MIGRATE=False')
    dbnames.add_argument(
        '--scratch', action='store_true', help='..: scratch, MIGRATE=False')

    # Subcommands
    subparsers = parser.add_subparsers()

    # `RUN`
    parser_run = subparsers.add_parser(
        'run',
        help='start a one-off Odoo service')
    parser_run.add_argument(
        '-p', '--port', default=80, help='port to allocate')
    parser_run.add_argument('-q', '--quiet', action='store_true')
    parser_run.set_defaults(
        func=run,
        port=80,
    )

    # `MIGRATE`
    parser_migrate = subparsers.add_parser(
        'migrate',
        help='migrate a specified database to the given version')
    parser_migrate.add_argument('dbname')  # TODO really?
    parser_migrate.add_argument('version')
    parser_migrate.set_defaults(
        func=migrate,
        version='latest',
    )

    # `DROPDB`
    parser_dropdb = subparsers.add_parser(
        'dropdb',
        help='get rid of a specified database')

    parser_dropdb.set_defaults(
        func=dropdb,
        dbname=False,
    )

    # `FORK`
    parser_fork = subparsers.add_parser(
        'fork',
        help='clone core db (odoodb), name it like current branch')
    parser_fork.set_defaults(
        func=fork,
    )

    # `TEST`
    parser_test = subparsers.add_parser(
        'test',
        help='upgrade the given module(s) while running tests on it')
    parser_test.set_defaults(
        func=test,
    )

    return parser.parse_known_args()


def _default_dbname():
    branch = resolve_context().get('repo').head.shorthand
    print('Running on branch {}'.format(branch))
    if branch == 'HEAD':  # detached head state
        return 'scratch'
    elif branch == 'master':  # core
        return 'odoodb'
    else:
        return branch


def resolve_context(args):
    ctx = {
        # TODO: drop extra dependency? this could be resolved by bare os.system
        'repo': Repository(discover_repository(os.getcwd())),
    }

    if args.core:
        args.dbname = 'odoodb'
    elif args.scratch:
        args.dbname = 'scratch'
    elif args.test:
        args.dbname = 'testdb'

    return ctx


def squash(args, prefix='', argprefix='-', separator='='):
    """Flatten a dictionary of arguments into a single string. """
    res = []
    for k, v in args.items():
        if v is None:
            # pass a bare key w/out it's value for a long flags
            # like --stop-after-init
            res.append(str(k))
        else:
            cval = '{}{}{}{}'.format(argprefix, k, separator, v)
            if prefix:
                cval = prefix + ' ' + cval
            res.append(cval)
    return ' '.join(res)


def dodoo_execute(cmd, args):
    if not args.dryrun:
        pprint('Executing {}'.format(cmd), log_decoration=' :: ')
    else:
        pprint('Would execute {}'.format(cmd), log_decoration=' -- ')
    not args.dryrun and os.system(cmd)


def subcommand(f, *args, **kwargs):
    """Defines a subcommand of a top-level sript.

    Each of decorated methods should return a tuple in the given order:
    `service` :str: a combination of service from `docker-compose.yml`
    config (odoo|db) and a command to run in that service
    `env` :dict: a dictionary of parameters that are passed to `docker-compose`
    `subargs` :dict: same, but those are passed to subprocess
    """
    @wraps(f)
    def wrapper(*args, **kwargs):
        """Actually execute command."""
        self_args, positionals, ctx = args
        service, servicecmd, runtime, env, subargs, rest = f(*args, **kwargs)
        runtime = squash(runtime, prefix='', argprefix='-', separator=' ')
        env = squash(env, prefix='-e', argprefix='', separator='=')
        subargs = squash(subargs, prefix='', argprefix='--', separator='=')
        dcrm_prefix = 'docker-compose run --rm'
        dcrm_args = ' '.join(
            s for s in (runtime, env, service, servicecmd, subargs, rest) if s)
        cmd = dcrm_prefix + ' ' + dcrm_args
        dodoo_execute(cmd, args[0])
    return wrapper


@subcommand
def run(args, pos, ctx):
    service = 'odoo'
    servicecmd = 'odoo'
    runtime = {
        'p': '{}:8069'.format(args.port),
    }
    env = {
    }
    subargs = {
        'log-handler': 'werkzeug:WARNING' if args.quiet else "''",
        'workers': 0,
    }
    rest = pos
    return service, servicecmd, runtime, env, subargs, rest


@subcommand
def migrate(args, pos, ctx):
    service = 'odoo'
    servicecmd = 'migrate'
    runtime = {}
    if args.version == 'latest':
        migration_file = os.path.join(
            ctx['repo'].workdir, 'odoo', 'migration.yml')
        with open(migration_file, 'r') as migration_yml:
            for line in reversed(list(migration_yml)):
                if 'version:' in line:
                    args.version = line.split()[-1]
                    break
    env = {
        'MARABUNTA_FORCE_VERSION': args.version,
        'DB_NAME': args.dbname,
    }
    subargs = {}
    rest = pos
    return service, servicecmd, runtime, env, subargs, rest


@subcommand
def dropdb(args, pos, ctx):
    service = 'odoo'
    servicecmd = 'dropdb'
    runtime = {}
    env = {
        'DBNAME': ctx.get('override_db') or args.dbname
    }
    subargs = {}
    rest = pos
    return service, servicecmd, runtime, env, subargs, rest


@subcommand
def fork(args, pos, ctx):
    pass


def main():
    args, positionals = parse_arguments()
    ctx = resolve_context(args)
    args.func(args, positionals, ctx)
    exit(0)


if __name__ == '__main__':
    main()
